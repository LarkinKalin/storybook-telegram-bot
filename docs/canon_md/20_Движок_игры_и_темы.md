# 20 — Движок игры и темы
Источник истины: 20_Движок_игры_и_темы.docx
ENGINE SPEC v0.1 — Канон движка интерактивной сказки (MVP)
Проект: Telegram-бот интерактивной сказки (русская аудитория)
Статус: Canon candidate (fixed)
________________________________________
0) Зачем engine вообще нужен
Если оставить всё “как чат с LLM”:
•	история течёт бесконечно,
•	выбор ребёнка почти не влияет на результат,
•	у родителя ощущение “болтовня”, а не игра.
Engine нужен, чтобы:
1.	история была ограниченной по длине (8/10/12 шагов),
2.	выбор ребёнка накапливал последствия (через скрытые параметры),
3.	история вела к понятному финалу (5 финалов),
4.	при шуме/ерунде игра не ломалась, а мягко закрывалась.
________________________________________
1) Главная идея механики (простыми словами)
Игрок видит сказку по шагам. На каждом шаге он:
•	жмёт одну из кнопок A/B/C, или
•	пишет “свой вариант” (free-text).
Движок механику не показывает, но внутри:
•	ведёт скрытые параметры героя (0..10),
•	фиксирует голоса на вехах (ключевых моментах),
•	в конце выбирает финал по формуле,
•	просит LLM написать эпилог и мораль под выбранный финал.
________________________________________
2) Граница ответственности (кто что делает)
Engine делает
•	считает шаги (1..N), где N ∈ {8,10,12},
•	хранит параметры (T1..T6),
•	применяет deltas (из кнопок или классификатора free-text),
•	отслеживает noise_streak,
•	выбирает финал (F1..F5) по формуле,
•	логирует решения так, чтобы они были воспроизводимы и объяснимы.
Engine НЕ делает
•	не пишет текст сказки,
•	не “придумывает мораль” сам,
•	не зависит от Telegram UI (видит только “варианты выбора”),
•	не занимается фильтрами контента (это отдельный слой).
LLM делает
•	пишет текст шага (сцену и варианты A/B/C),
•	классифицирует free-text (intent → trait, confidence, deltas) — по отдельному контракту,
•	пишет финал/мораль под final_id и модификаторы.
________________________________________
3) Параметры (Traits) — сколько и какие
3.1. Почему 6, а не 3 и не 12
•	3 мало: финалы слишком грубые, мало смысла в выборе.
•	12 много: контент и классификация начнут ломаться, будет шум.
•	6 — верхняя граница “управляемо, но уже богато”.
3.2. Список параметров (канон)
Все параметры скрыты от игрока.
•	T1 Bravery — Смелость
•	T2 Kindness — Доброта
•	T3 Wisdom — Мудрость
•	T4 Honesty — Честность
•	T5 Responsibility — Ответственность
•	T6 Fantasy — Фантазия/Хаос (абсурдные, смешные решения)
Таблица соответствия (источник истины для всех контрактов):
•	bravery → T1
•	kindness → T2
•	wisdom → T3
•	honesty → T4
•	responsibility → T5
•	fantasy → T6
3.3. Диапазон и старт
•	каждый Ti в диапазоне 0..10
•	старт: 5
3.4. Clamp
После применения deltas:
•	Ti = min(10, max(0, Ti))
________________________________________
4) Дельты (изменения параметров) и лимиты
4.1. Формат
На шаге может быть 0, 1 или 2 изменения (в MVP).
Примеры:
•	[{trait: T1, delta: +2}]
•	[{trait: T2, delta: +1}, {trait: T3, delta: +1}]
•	neutral: []
4.2. Лимит “сколько можно сдвинуть за шаг”
Лимиты зависят от типа шага:
•	NORMAL: sum_abs_limit = 2
•	SEMI: sum_abs_limit = 3
•	HEAVY: sum_abs_limit = 4
Где sum_abs = Σ |Δi|.
4.3. Отрицательные дельты (чтобы не травмировать и не бесить родителей)
Отрицательные изменения допустимы только на “весомых” шагах и при высокой уверенности.
•	NORMAL: отрицательные по T1..T5 запрещены
•	SEMI: допускается одна -1 по T1..T5 при confidence ≥ 0.75
•	HEAVY: допускается одна -2 по T1..T5 при confidence ≥ 0.80
T6 может расти чаще (юмор), но не должен ломать структуру.
4.4. Нормализация (если кто-то прислал “слишком жирно”)
Если deltas выходят за лимиты:
•	engine режет до лимитов,
•	логирует:
o	content_delta_clamped=true (если пришло от кнопок/контента),
o	classifier_delta_clamped=true (если пришло от free-text).
________________________________________
5) Длина истории и шаги
5.1. Длины (канон MVP)
По умолчанию N=8. Можно выбрать N=10 или N=12.
5.2. ENDING и CLOSE
•	ENDING — последний сюжетный шаг (эпилог + мораль)
•	CLOSE — техническое закрытие: кнопки “сыграть ещё”, “в меню”, “повторить”
________________________________________
6) Вехи (Milestones) и нормализация по progress
6.1. Зачем вехи
Вехи нужны, чтобы:
•	ключевые решения были весомее,
•	tie-break был объяснимым,
•	распределение не “плыло” от длины N.
6.2. Канонические вехи v0.1
•	M2 — развилка/выбор направления
•	M6 — предкульминация
•	M7 — финальное испытание
6.3. Формулы v0.1
Для длины N:
•	M2_step = 3
•	M6_step = round(0.65*(N-1)) + 1
•	M7_step = round(0.80*(N-1)) + 1
•	ENDING_step = N
Коллизии (канон): если M6_step == M7_step, то
M7_step = min(N-1, M7_step + 1).
6.4. Таблица вех для 8/10/12
N	N-1	M2	M6	M7	ENDING
8	7	3	6	7	8
10	9	3	7	8	10
12	11	3	8	10	12
6.5. Нормализация по progress (задел v0.2)
Engine хранит:
•	progress = (step-1)/(N-1) в диапазоне 0..1.
Если когда-нибудь потребуется переопределять вехи:
•	M2 ≈ 0.25
•	M6 ≈ 0.65
•	M7 ≈ 0.80
Формулы по шагам остаются дефолтом v0.1.
________________________________________
7) Источники deltas: кнопки vs free-text
7.1. Кнопки (A/B/C) — главный источник истины
Если игрок нажал кнопку:
•	engine применяет deltas из контента,
•	классификатор для кнопок не используется (можно логировать пассивно).
Если mapping отсутствует:
•	выбор считается neutral_transition,
•	лог: content_missing_mapping=true.
7.2. Free-text — через классификатор
Если игрок ввёл текст:
•	engine вызывает классификатор,
•	получает: intent_trait, deltas, confidence, safety, tags.
7.3. Пороги confidence (разнесены)
•	если confidence < 0.65 → neutral (deltas игнорируются)
•	intent учитывается в tie-break только если confidence ≥ 0.70
Минусы:
•	SEMI: confidence ≥ 0.75
•	HEAVY: confidence ≥ 0.80
7.4. JSON fail-safe (если классификатор сломан)
Если JSON не распарсился/невалиден:
•	intent_trait = neutral
•	deltas = []
•	confidence = 0
•	safety = unclear
•	tags = []
Дальше поведение как safety=unclear.
________________________________________
8) Neutral transition (управляемое “на откуп модели”)
8.1. Когда возникает neutral
Neutral случается, если:
•	confidence < 0.65
•	parse_fail/invalid_schema
•	safety=unclear
•	отсутствует mapping кнопок
•	ввод определён как noise (см. 9)
8.2. Что делает engine на neutral
•	НЕ применяет deltas
•	НЕ фиксирует голос (если milestone)
•	продолжает историю
•	логирует: neutral=true + neutral_reason
8.3. Что обязана сделать LLM на neutral (канон)
Neutral допускает “текстовую вариативность”, но НЕ структурную.
LLM обязана:
1.	продолжать историю так, будто выбран один из A/B/C (внутренне),
2.	не вводить четвёртый путь и новые типы действий,
3.	не усиливать последствия (никаких “навсегда потерял друга”),
4.	держать “безопасный ход” по тону.
Параметры генерации:
•	temperature = 0 (или минимально возможная)
•	top_p фиксирован
________________________________________
9) Политика “шумного ребёнка” (noise_streak) — детерминированно
9.1. Детерминированное определение noise
Ввод считается noise_input=true, если выполнено ЛЮБОЕ:
1.	len(trim(text)) < 3
2.	текст матчится regex:
o	только точки/многоточия/пробелы: ^[\s\.\…]+$
o	один “паразит” (без учёта регистра):
{ "не знаю","незнаю","хз","лол","ок","угу","ээ","а","мм","...","…" }
3.	классификатор вернул tag noise (доп. сигнал)
Engine определяет noise сам, tag noise лишь усиливает уверенность.
9.2. Счётчик шума
•	если noise_input=true → noise_streak += 1
•	если шаг не шумный и не neutral по шуму → noise_streak = 0
9.3. Поведение
•	noise_streak >= 3 → следующий шаг: скрыть free-text, оставить только A/B/C
•	noise_streak >= 5 → финал F5 с причиной noise_abort
________________________________________
10) Финалы (F1–F5): смысл
•	F1 — Храбрый успех
•	F2 — Добрый успех
•	F3 — Умный успех
•	F4 — Светлая гармония
•	F5 — Смешная гармония / мягкое закрытие
У F5 две причины:
•	chaos_dominant
•	noise_abort
________________________________________
11) Формула выбора финала (доминанта по T1..T5)
11.1. Обозначения
•	Core = {T1..T5}
•	maxCore = max(T1..T5)
•	top1Core, top2Core — два максимума среди T1..T5
•	gapCore = top1Core - top2Core
•	leaderCore — argmax(T1..T5); если лидеров несколько → leaderCore = tie
•	leaderCore_unique = (leaderCore != tie)
•	minCore = min(T1..T5)
•	T6 = Fantasy
•	noise_streak как выше
11.2. Маппинг доминанты Core → финал стиля
•	если leaderCore ∈ {T1, T5} → F1 (brave/reliable)
•	если leaderCore ∈ {T2, T4} → F2 (kind/truthful)
•	если leaderCore = T3 → F3 (wise)
11.3. Порядок правил (важен)
Финал выбирается первым сработавшим:
Rule 0: noise_abort
если noise_streak >= 5 → final_id=F5, F5_reason=noise_abort
Rule 1: chaos_dominant (конфликт-резолвер)
если T6 >= 9 и maxCore <= 8 → final_id=F5, F5_reason=chaos_dominant
Пояснение: хаос не должен отменять “реальную победу”, поэтому правило работает только если Core не достиг порога доминанты.
Rule 2: доминантная победа (уникальный лидер)
если maxCore >= 9 и gapCore >= 2 и leaderCore_unique=true →
final_id = map_core_leader_to_final(leaderCore)
Rule 3: высокая, но спорная доминанта
если maxCore >= 9 и (gapCore < 2 или leaderCore_unique=false) → tie-break (см. 12)
если tie-break не дал результата → final_id=F4
Rule 4: всё остальное
иначе → final_id=F4
11.4. Подтон F4
Если final_id=F4:
•	F4_tone = growth если minCore <= 3
•	F4_tone = success если minCore >= 4
________________________________________
12) Tie-break через вехи (Milestone votes)
12.1. Голос на вехе
На шагах M2/M6/M7 engine может зафиксировать milestone_vote по trait.
Источники:
•	кнопка → голос из контента
•	free-text → intent_trait, если confidence ≥ 0.70
•	если milestone был neutral → голос = none
milestone_vote_reason enum (канон): { content, intent, none }
12.2. Как tie-break выбирает финал
Tie-break считается по голосам по Core (T1..T5):
•	если один trait набрал больше голосов → победа через mapping 11.2
•	если равенство/нет голосов → final_id=F4
Если M7 голос none и high_tie:
•	принудительно final_id=F4
•	лог: milestone_vote_missing=["M7"]
________________________________________
13) Зачем тогда T4/T5 дополнительно, кроме маппинга
T4/T5:
•	могут стать доминантой через Core → влиять на F1/F2 (по маппингу),
•	влияют на стиль морали через модификаторы:
Если T4 ≥ 7 → style_modifiers += ["truthful"]
Если T5 ≥ 7 → style_modifiers += ["reliable"]
При низких значениях (≤3) мораль “про рост” без стыда и наказания.
________________________________________
14) Роли контента
Контент обязан на шаг дать:
•	сцену,
•	A/B/C,
•	deltas для кнопок (в пределах лимитов),
•	milestone_vote (если milestone) или явное none.
Если deltas превышают лимиты:
•	engine режет и логирует content_delta_clamped=true.
Если mapping отсутствует:
•	neutral_transition + content_missing_mapping=true.
________________________________________
15) Обязательное логирование (enum причин)
15.1. neutral_reason enum (канон)
neutral_reason ∈ {
•	low_confidence,
•	parse_fail,
•	safety_unclear,
•	missing_mapping,
•	noise_input
}
15.2. На каждом шаге
•	session_id
•	step, N
•	step_type
•	input_mode
•	choice (A/B/C/none)
•	neutral + neutral_reason
•	confidence (если free-text)
•	noise_input (bool)
•	applied_deltas (после нормализации)
•	traits_after (T1..T6)
•	noise_streak
15.3. На milestones
•	milestone_id
•	milestone_vote
•	milestone_vote_reason (content|intent|none)
15.4. На финале
•	final_id
•	если F5: F5_reason
•	если F4: F4_tone, F4_leading_trait (optional)
•	tie_break_source
•	milestone_votes
•	gap_case
F4_leading_trait (если используется):
•	если tie-break имел победителя по голосам, но финал всё равно F4 (например, из-за отсутствия доминанты по правилам), то F4_leading_trait = winner_trait
•	иначе F4_leading_trait = none
________________________________________
16) Решающая матрица финалов (Core)
Приоритет	Условие	Результат	Пояснение
0	noise_streak ≥ 5	F5 + noise_abort	мягко закрываем шум
1	T6 ≥ 9 и maxCore ≤ 8	F5 + chaos_dominant	хаос только если “победа” Core не достигнута
2	maxCore ≥ 9 и gapCore ≥ 2 и leaderCore_unique=true	F1/F2/F3 по mapping	ясная доминанта
3	maxCore ≥ 9 и (gapCore < 2 или leaderCore_unique=false)	tie-break → F1/2/3 или F4	спорная доминанта
4	иначе	F4	светлая гармония
________________________________________
17) Матрица дельт
Step type	sum_abs_limit	Минусы по T1..T5	Требование confidence	Нормализация
NORMAL	2	запрещены	—	clamp + резка
SEMI	3	≤1 шт. -1	≥0.75	иначе убрать минус
HEAVY	4	≤1 шт. -2	≥0.80	иначе убрать минус
neutral:
•	confidence < 0.65 → neutral_transition
________________________________________
18) DoD канона
Канон v0.1 готов, если:
1.	доминанта и финал воспроизводимы по логам,
2.	формулы и примеры вех совпадают,
3.	определены enum’ы (neutral_reason, milestone_vote_reason),
4.	noise детерминирован,
5.	есть две матрицы: финалов и дельт,
6.	есть fail-safe для JSON классификатора,
7.	определено поведение при leaderCore=tie и коллизиях M6/M7.

